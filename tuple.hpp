#ifndef SS_TUPLE_HPP
#define SS_TUPLE_HPP
#include <cmath>
#include "dict.hpp"
#include "list.hpp"

// Global types to match autogenerated code
typedef int __ss_int;
typedef double __ss_float;
typedef bool __ss_bool;

namespace shedskin {
// Forward declarations
template<class T> class set;
class str;

// Iterator base class with list conversion
template<typename T>
class __iter {
public:
    bool __stop_iteration;
    
    __iter() : __stop_iteration(false) {}
    virtual ~__iter() {}
    virtual T __get_next() = 0;
    
    // Convert to list
    operator list<T>*() {
        list<T>* result = new list<T>();
        T item;
        while (!__stop_iteration) {
            item = __get_next();
            if (!__stop_iteration) {
                result->append(item);
            }
        }
        return result;
    }
};

// List iterator
template<typename T>
class __list_iterator : public __iter<T> {
    list<T>* lst;
    __ss_int index;
public:
    __list_iterator(list<T>* l) : lst(l), index(0) {}
    
    T __get_next() override {
        if (!lst || index >= lst->__len__()) {
            this->__stop_iteration = true;
            return T();
        }
        return lst->__getitem__(index++);
    }
};

// Range class
class __xrange : public __iter<__ss_int> {
    __ss_int start, stop, step, current;


public:
    class for_in_loop {
        __xrange* range;
        __ss_int value;

    public:
        // Constructeur par dÃ©faut
        for_in_loop() : range(nullptr), value(0) {}

        // Constructeur principal
        for_in_loop(__xrange* r) : range(r), value(r->current) {}

        bool __next__(__ss_int& ref) {
            if (range && range->current < range->stop) {
                ref = range->current;
                range->current += range->step;
                return true;
            }
            return false;
        }
    };

    __xrange(__ss_int stop) : start(0), stop(stop), step(1), current(0) {}
    __xrange(__ss_int start, __ss_int stop) : start(start), stop(stop), step(1), current(start) {}
    __xrange(__ss_int start, __ss_int stop, __ss_int step) 
        : start(start), stop(stop), step(step), current(start) {}
    
    __ss_int __len__() { return (stop - start + step - 1) / step; }
    
    __ss_int __get_next() override {
        if ((step > 0 && current >= stop) || (step < 0 && current <= stop)) {
            this->__stop_iteration = true;
            return 0;
        }
        __ss_int result = current;
        current += step;
        return result;
    }
};

inline shedskin::__xrange* range(__ss_int start, __ss_int stop, __ss_int step = 1) {
    return new shedskin::__xrange(start, stop, step);
}

// Helper functions
template<typename T>
static __list_iterator<T>* __to_iter(list<T>* lst) {
    return new __list_iterator<T>(lst);
}

template<typename T>
static T* __to_iter(T* iter) {
    return iter;
}

// Generator macros - modified to work with autogenerated code
#define FOR_IN(e,iter,iter_name,counter,loop_name) { \
    auto __iter_##counter = __to_iter(iter); \
    bool __yielded_##counter = false; \
    while (!__iter_##counter->__stop_iteration) { \
        e = __iter_##counter->__get_next(); \
        if (!__yielded_##counter) { \
            __yielded_##counter = true; \
            goto __after_yield_##counter; \
        } \
        if (0) { \
            __after_yield_##counter: \
            continue; \
        }

#define FAST_FOR(e,start,stop,step,counter1,counter2) \
    for(__ss_int e = start; e < stop; e += step)

#define FOR_IN_DICT(d,dict_name,iter_name,counter) \
    for(auto iter_name = d->begin(); iter_name != d->end(); ++iter_name)

#define END_FOR } }

// Zero function for default values
template<typename T>
T __zero() { 
    return T();
}

extern __ss_int __result;

} // namespace shedskin

// Make iterator type available globally to match autogenerated code
template<typename T>
using iter = shedskin::__iter<T>;

// Make zero function available globally
using shedskin::__zero;

#endif