#ifndef SS_TUPLE_HPP
#define SS_TUPLE_HPP
#include <cmath>
#include "dict.hpp"
#include "list.hpp"

// Global types to match autogenerated code
typedef int __ss_int;
typedef double __ss_float;
typedef bool __ss_bool;

namespace shedskin {

// Forward declarations
template<class T> class set;
class str;

// Simple tuple implementation compatible with ESBMC
template<typename T>
class tuple {
private:
    list<T>* data;
    __ss_int size;
    
public:
    tuple(__ss_int count, ...) {
        data = new list<T>();
        va_list args;
        va_start(args, count);
        size = count;
        
        for(__ss_int i = 0; i < count; i++) {
            T value = va_arg(args, T);
            data->append(value);
        }
        
        va_end(args);
    }
    
    // Get length of tuple
    __ss_int __len__() const {
        return size;
    }
    
    // Get item at index
    T __getitem__(__ss_int index) const {
        if(index < 0 || index >= size) {
            throw std::runtime_error("Tuple index out of range");
        }
        return data->__getitem__(index);
    }

    T __getfirst__() const {
        return __getitem__(0);
    }

    T __getsecond__() const {
        if (size < 2) {
            throw std::runtime_error("Tuple does not have a second element");
        }
        return __getitem__(1);
    }

    
    // Support for iteration
    class iterator {
    private:
        const tuple<T>* tup;
        __ss_int index;
    public:
        iterator(const tuple<T>* t, __ss_int i) : tup(t), index(i) {}
        T operator*() const { return tup->__getitem__(index); }
        iterator& operator++() { ++index; return *this; }
        bool operator!=(const iterator& other) const { return index != other.index; }
    };
    
    iterator begin() const { return iterator(this, 0); }
    iterator end() const { return iterator(this, size); }
};

// Assertion function to match Python's assert
inline void __ss_assert(__ss_bool condition, const char* message) {
    if (!condition) {
        throw std::runtime_error(message);
    }
}

// Support for len() function
template<typename T>
__ss_int len(tuple<T>* t) {
    return t->__len__();
}

// Rest of the original code...
template<typename T>
class __iter {
public:
    bool __stop_iteration;
    
    __iter() : __stop_iteration(false) {}
    virtual ~__iter() {}
    virtual T __get_next() = 0;
    
    operator list<T>*() {
        list<T>* result = new list<T>();
        T item;
        while (!__stop_iteration) {
            item = __get_next();
            if (!__stop_iteration) {
                result->append(item);
            }
        }
        return result;
    }
};

// Keep rest of the original code unchanged...

} // namespace shedskin

// Make tuple type available globally
template<typename T>
using __ss_tuple = shedskin::tuple<T>;

// Make assertion and len functions available globally
using shedskin::__ss_assert;
using shedskin::len;

#endif